-- Copyright 2021 Kafka-Tarantool-Loader
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ashitov.
--- DateTime: 8/4/20 3:41 PM
---

local fiber = require('fiber')
local log = require('log')
local checks = require('checks')
local cartridge = require('cartridge')
local pool = require('cartridge.pool')
local error_repository = require('app.messages.error_repository')
local TIMEOUT = 1

local kafka_error_handler_transformation = {}
kafka_error_handler_transformation.__index = kafka_error_handler_transformation
kafka_error_handler_transformation.__type = 'error_transformation'
kafka_error_handler_transformation.__call = function (cls, ...)
    return cls.new(...)
end

local function unsubscribe(topic_name)
    checks('string')

    -- get all kafka connectors
    local kafka_connectors =  cartridge.rpc_get_candidates('app.roles.adg_kafka_connector',{leader_only = true})

    if #kafka_connectors == 0 then
        return false,error_repository.get_error_code('API_KAFKA_001')
    end


    local futures = {}

    for _,connector in ipairs(kafka_connectors) do
        local conn, err = pool.connect(connector, {wait_connected = 1.5})
        if conn == nil then
            return false,error_repository.get_error_code('API_KAFKA_002',{err=err})
        else
            local future = conn:call('unsubscribe_from_topic',
                    {topic_name},{is_async=true})
            table.insert(futures,future)
        end
    end

    for _,future in ipairs(futures) do
        future:wait_result(30)
        local res,err = future:result()

        if res == nil then
            return  false,error_repository.get_error_code('API_KAFKA_UNSUBSCRIPTION_002',{topicName = topic_name, err=err})
        end

        if res[2] ~= nil then
            return  false,error_repository.get_error_code('API_KAFKA_UNSUBSCRIPTION_002',{topicName = topic_name, err=res[2]})
        end

        --Suggest that false|nil returned if topic not found
        if res[1] == false then
            return  false,error_repository.get_error_code('API_KAFKA_UNSUBSCRIPTION_001',{topicName = topic_name})
        end
    end

    return true,nil
end

local function send_msgs(msgs)
    checks('table')
    local state_master = cartridge.rpc_get_candidates('app.roles.adg_state', { leader_only = true })
    if #state_master == 0 then
        return false, 'ERROR: No app.roles.adg_state role found'
    end

    local conn, _ = pool.connect(state_master[1]) -- always one master
    if conn == nil then
        return false, 'ERROR: Cannot connect to app.roles.adg_state role'
    end

    -- answer?
    conn:call("insert_kafka_error_msgs",
            {msgs},
            {is_async=true})

    return true, nil
    end


function kafka_error_handler_transformation.init(channel_capacity)
    local self = setmetatable({}, kafka_error_handler_transformation)
    self.process_channel = fiber.channel(channel_capacity)
    self.process_fiber = fiber.new(function()

        local buffer = {}
        while true do
            if (self.process_channel:is_closed()) then
                log.warn('WARN: Channels closed in fiber %s', "kafka_error_msg_fiber")
                return
            end

            local input = self.process_channel:get(TIMEOUT)

            if input ~= nil then

                -- type check
                if type(input) ~= "table" then
                    log.warn("WARN: Bad message format in kafka error handler - %s", type(input))
                    goto continue
                end
                -- trying to extract kafka msg metadata
                local msg = input.msg

                if msg == nil or type(msg) ~= "table" then
                    log.warn("WARN: Cannot find kafka message metadata in kafka error handler")
                    goto continue
                end

                -- trying to extract error msg
                local err = input.err
                log.error(err)
                if err == nil or type(err) ~= "string" then
                    err = "ERROR: Kafka consumer error"
                end

                -- trying to extract error fiber name
                local fiber_name = input.fiber_name

                if fiber_name == nil or type(fiber_name) ~= "string" then
                    fiber_name = 'unknown'
                end

                -- trying to extract error timestamp
                local timestamp = input.timestamp

                if timestamp == nil or type(timestamp) ~= "number" then
                    timestamp = 0
                end

                local unsubscribe_ok,unsubscribe_err = unsubscribe(msg.topic)

                if unsubscribe_ok == nil or unsubscribe_ok == false then
                    log.error("ERROR: Kafka error handler unsubscribe error - %s",unsubscribe_err)
                end


                table.insert(buffer,{
                    topic_name = msg.topic,
                    partition_name = tostring(msg.partition),
                    offset = msg.offset,
                    key = msg.key,
                    value = '',
                    fiber_name = fiber_name,
                    error_timestamp = timestamp,
                    error_msg = err
                })

                if #buffer >= 500 then
                    local res,err = send_msgs(buffer)
                    if res == nil or res == false then
                        log.error("ERROR: Kafka error handler send error - %s",err)
                    end
                    buffer = {}
                end
                ::continue::
            else
                local res,err = send_msgs(buffer)
                if res == nil or res == false then
                    log.error("ERROR: Kafka error handler send error - %s",err)
                end
                buffer = {}
            end
            fiber.yield()
        end

    end)
    self.process_fiber:name("kafka_error_msg_fiber")
    return self
end

function kafka_error_handler_transformation.get_result_channel(self)
    return self.process_channel
end

return kafka_error_handler_transformation